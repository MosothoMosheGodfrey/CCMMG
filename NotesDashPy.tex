
#import numpy as np
#import pandas as pd
#from sklearn.model_selection import train_test_split
#from sklearn.linear_model import LinearRegression
#from sklearn.metrics import mean_squared_error

## Generate synthetic data
#np.random.seed(0)
#n_samples = 1000

#unemployment_rate = np.random.uniform(3.0, 12.0, n_samples)  # Generate random unemployment rates
#account_closure = 2000 - 100 * unemployment_rate + np.random.normal(0, 50, n_samples)  # Generate account closure data

## Create a DataFrame
#data = pd.DataFrame({'unemployment_rate': unemployment_rate, 'account_closure': account_closure})

## Split data into features and target
#X = data[['unemployment_rate']]
#y = data['account_closure']

## Split data into training and testing sets
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

## Create and train a Linear Regression model
#model = LinearRegression()
#model.fit(X_train, y_train)

## Make predictions on the test set
#y_pred = model.predict(X_test)

## Evaluate the model
#mse = mean_squared_error(y_test, y_pred)
#print(f'Mean Squared Error: {mse}')


















#import numpy as np
#import pandas as pd
#from sklearn.model_selection import train_test_split
#from sklearn.linear_model import LinearRegression
#from sklearn.metrics import mean_squared_error

## Generate synthetic data
#np.random.seed(0)
#n_samples = 1000

## Generate synthetic data for multiple features
#unemployment_rate = np.random.uniform(3.0, 12.0, n_samples)
#interest_rate = np.random.uniform(0.01, 0.1, n_samples)
#customer_age = np.random.randint(18, 80, n_samples)
#account_closure = 2000 - 100 * unemployment_rate - 500 * interest_rate + 50 * customer_age + np.random.normal(0, 100, n_samples)

## Create a DataFrame
#data = pd.DataFrame({
    #'unemployment_rate': unemployment_rate,
    #'interest_rate': interest_rate,
    #'customer_age': customer_age,
    #'account_closure': account_closure
#})

## Split data into features and target
#X = data[['unemployment_rate', 'interest_rate', 'customer_age']]
#y = data['account_closure']

## Split data into training and testing sets
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

## Create and train a Linear Regression model
#model = LinearRegression()
#model.fit(X_train, y_train)

## Make predictions on the test set
#y_pred = model.predict(X_test)

## Evaluate the model
#mse = mean_squared_error(y_test, y_pred)
#print(f'Mean Squared Error: {mse}')





#import numpy as np
#import pandas as pd
#import matplotlib.pyplot as plt
#import seaborn as sns
#from sklearn.model_selection import train_test_split
#from sklearn.linear_model import LinearRegression
#from sklearn.metrics import mean_squared_error
#import statsmodels.api as sm

## Generate synthetic data
#np.random.seed(0)
#n_samples = 1000

## Generate synthetic data for multiple features
#unemployment_rate = np.random.uniform(3.0, 12.0, n_samples)
#interest_rate = np.random.uniform(0.01, 0.1, n_samples)
#customer_age = np.random.randint(18, 80, n_samples)
#account_closure = 2000 - 100 * unemployment_rate - 500 * interest_rate + 50 * customer_age + np.random.normal(0, 100, n_samples)

## Create a DataFrame
#data = pd.DataFrame({
    #'unemployment_rate': unemployment_rate,
    #'interest_rate': interest_rate,
    #'customer_age': customer_age,
    #'account_closure': account_closure
#})

## Split data into features and target
#X = data[['unemployment_rate', 'interest_rate', 'customer_age']]
#y = data['account_closure']

## Split data into training and testing sets
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

## Create and train a Linear Regression model
#model = LinearRegression()
#model.fit(X_train, y_train)

## Make predictions on the test set
#y_pred = model.predict(X_test)

## Calculate the Mean Squared Error
#mse = mean_squared_error(y_test, y_pred)

## Plot the data
#sns.pairplot(data, x_vars=['unemployment_rate', 'interest_rate', 'customer_age'], y_vars='account_closure', kind='scatter')
#plt.show()

## Perform statistical analysis with OLS (Ordinary Least Squares) regression
#X = sm.add_constant(X)  # Add a constant (intercept) term to the model
#model = sm.OLS(y, X).fit()
#print(model.summary())






import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm

from statsmodels.tsa.arima.model import ARIMA

# Generate synthetic data
np.random.seed(0)
n_samples = 100

# Generate synthetic data for multiple features 
unemployment_rate = np.random.uniform(3.0, 12.0, n_samples)
interest_rate = np.random.uniform(0.01, 0.1, n_samples)
customer_age = np.random.randint(18, 80, n_samples)
new_accounts = np.random.randint(0, 100, n_samples)
existing_accounts = np.random.randint(50, 500, n_samples)
gdp_growth = np.random.uniform(0.0, 3.0, n_samples)
inflation_rate = np.random.uniform(0.0, 2.0, n_samples)
account_closure = 2000 - 100 * unemployment_rate - 500 * interest_rate + 50 * customer_age + new_accounts - 10 * existing_accounts + np.random.normal(0, 100, n_samples)

# Create a DataFrame with datetime
date_rng = pd.date_range(start='1/1/2010', periods=n_samples, freq='M')
data = pd.DataFrame({
    'datetime': date_rng,
    'account_closure': account_closure,
    'unemployment_rate': unemployment_rate,
    'interest_rate': interest_rate,
    'customer_age': customer_age,
    'new_accounts': new_accounts,
    'existing_accounts': existing_accounts,
    'gdp_growth': gdp_growth,
    'inflation_rate': inflation_rate
})

## Perform time series analysis with ARIMA
#account_closures = data[['datetime', 'account_closure']].set_index('datetime')
#model = ARIMA(account_closures, order=(1, 1, 1))  # Example ARIMA order
#results = model.fit()
#print(results.summary())

## Plot the time series data
#plt.figure(figsize=(10, 5))
#plt.plot(account_closures)
#plt.title('Account Closures Over Time')
#plt.xlabel('Datetime')
#plt.ylabel('Account Closures')
#plt.show()






import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import statsmodels.api as sm

## Generate synthetic data
#np.random.seed(0)
#n_samples = 1000

## Generate synthetic data for multiple features
#unemployment_rate = np.random.uniform(3.0, 12.0, n_samples)
#interest_rate = np.random.uniform(0.01, 0.1, n_samples)
#customer_age = np.random.randint(18, 80, n_samples)
#new_accounts = np.random.randint(0, 100, n_samples)
#existing_accounts = np.random.randint(50, 500, n_samples)
#gdp_growth = np.random.uniform(0.0, 3.0, n_samples)
#inflation_rate = np.random.uniform(0.0, 2.0, n_samples)
#account_closure = 2000 - 100 * unemployment_rate - 500 * interest_rate + 50 * customer_age + new_accounts - 10 * existing_accounts + np.random.normal(0, 100, n_samples)

## Create a DataFrame
#data = pd.DataFrame({
    #'unemployment_rate': unemployment_rate,
    #'interest_rate': interest_rate,
    #'customer_age': customer_age,
    #'new_accounts': new_accounts,
    #'existing_accounts': existing_accounts,
    #'gdp_growth': gdp_growth,
    #'inflation_rate': inflation_rate,
    #'account_closure': account_closure
#})

## Perform basic statistical analysis
#summary = data.describe()

## Calculate correlations and create a correlation matrix plot
#correlation_matrix = data.corr()
#plt.figure(figsize=(10, 8))
#sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
#plt.title('Correlation Matrix')
#plt.show()

## Split data into features and target
#X = data[['unemployment_rate', 'interest_rate', 'customer_age', 'new_accounts', 'existing_accounts', 'gdp_growth', 'inflation_rate']]
#y = data['account_closure']

## Split data into training and testing sets
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

## Create and train a Linear Regression model
#model = LinearRegression()
#model.fit(X_train, y_train)

## Make predictions on the test set
#y_pred = model.predict(X_test)

## Evaluate the model
#mse = mean_squared_error(y_test, y_pred)
#print(f'Mean Squared Error: {mse}')

## Perform statistical analysis with OLS (Ordinary Least Squares) regression
#X = sm.add_constant(X)  # Add a constant (intercept) term to the model
#model = sm.OLS(y, X).fit()
#print(model.summary())





import pandas as pd
import matplotlib.pyplot as plt

## Load your data into a DataFrame
#data = pd.read_csv('your_data.csv')  # Replace 'your_data.csv' with your data file

# Summary statistics
summary = data.describe()
print(summary)

# Create a line plot to visualize trends over time
plt.figure(figsize=(12, 6))
plt.plot(data['datetime'], data['account_closure'], label='Account Closure')
plt.plot(data['datetime'], data['new_accounts'], label='New Accounts')
plt.plot(data['datetime'], data['existing_accounts'], label='Existing Accounts')
plt.xlabel('Month')
plt.ylabel('Count')
plt.title('Monthly Data Trends')
plt.legend()
 


plt.figure(figsize=(10, 8))
correlation_matrix = data.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')






plt.figure(figsize=(10, 8))
from statsmodels.tsa.seasonal import seasonal_decompose
# Set 'datetime' as the index
data['datetime'] = pd.to_datetime(data['datetime'])
data.set_index('datetime', inplace=True)

# Decompose the time series into trend, seasonality, and residuals
result = seasonal_decompose(data['account_closure'], model='additive')
result.plot()



# Group data by month
monthly_stats = data.groupby(data.index.to_period('M')).agg({
    'account_closure': 'sum',
    'new_accounts': 'mean',
    'existing_accounts': 'mean',
    'customer_age': 'mean',
    'interest_rate': 'mean',
    'gdp_growth': 'mean',
    'inflation_rate': 'mean',
    'unemployment_rate': 'mean'
})

print(monthly_stats)


#plt.show()
 
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
 
# Plot the time series data
plt.figure(figsize=(12, 6))
plt.plot(data['account_closure'], label='Account Closure', linestyle='-', marker='o')
plt.xlabel('Month')
plt.ylabel('Account Closure')
plt.title('Account Closure Over Time')
plt.legend()
plt.grid(True)
 
# Calculate and plot the correlation matrix
correlation_matrix = data.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix')
#plt.show()






import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
 

# Plot the time series data
plt.figure(figsize=(12, 6))
plt.plot(data['account_closure'], label='Account Closure', linestyle='-', marker='o')
plt.xlabel('Month')
plt.ylabel('Account Closure')
plt.title('Account Closure Over Time')
plt.legend()
plt.grid(True)
 
# Check stationarity using ADF test
adf_result = adfuller(data['account_closure'])
print("ADF Statistic:", adf_result[0]) 
print("p-value:", adf_result[1])

# Perform differencing if needed (if data is not stationary)
# data['account_closure_diff'] = data['account_closure'].diff().dropna()

# Fit an ARIMA model
order = (1, 1, 1)  # Example order, tune as needed
model = ARIMA(data['account_closure'], order=order)
model_fit = model.fit()

 


# Summary of the ARIMA model
print(model_fit.summary())

# Plot the residuals
plt.figure(figsize=(12, 6))
residuals = pd.DataFrame(model_fit.resid)
residuals.plot(title='Residuals')
 
## Forecast future values
#n_forecast = 12  # Example: forecast the next 12 months
#forecast, stderr, conf_int = model_fit.forecast(steps=n_forecast, alpha=0.05)

## Plot the forecasted values
#plt.figure(figsize=(12, 6))
#plt.plot(data.index, data['account_closure'], label='Actual', marker='o', linestyle='-')
#plt.plot(pd.date_range(start=data.index[-1], periods=n_forecast, freq='M'), forecast, label='Forecast', linestyle='--')
#plt.xlabel('Month')
#plt.ylabel('Account Closure')
#plt.title('Account Closure Forecast')
#plt.legend()
#plt.grid(True)





import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# Generate synthetic non-financial data
n_samples = 1000
data = pd.DataFrame({
    'customer_age': np.random.randint(18, 80, n_samples),
    'customer_satisfaction': np.random.uniform(1, 5, n_samples),
    'customer_service_interactions': np.random.randint(0, 10, n_samples),
    'account_closure': np.random.choice([0, 1], size=n_samples)
})

# Split data into features and target
X = data[['customer_age', 'customer_satisfaction', 'customer_service_interactions']]
y = data['account_closure']

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train a Logistic Regression model
model = LogisticRegression()
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy}')





import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have a DataFrame 'data' with non-financial factors and 'account_closure' column

# Scatter plot of 'customer_age' vs. 'account_closure'
plt.figure(figsize=(12, 6))
sns.scatterplot(data=data, x='customer_age', y='account_closure')
plt.title('Customer Age vs. Account Closure')
plt.xlabel('Customer Age')
plt.ylabel('Account Closure')
plt.grid(True)
 
# Scatter plot of 'customer_satisfaction' vs. 'account_closure'
plt.figure(figsize=(12, 6))
sns.scatterplot(data=data, x='customer_satisfaction', y='account_closure')
plt.title('Customer Satisfaction vs. Account Closure')
plt.xlabel('Customer Satisfaction')
plt.ylabel('Account Closure')
plt.grid(True)
 
# Scatter plot of 'customer_service_interactions' vs. 'account_closure'
plt.figure(figsize=(12, 6))
sns.scatterplot(data=data, x='customer_service_interactions', y='account_closure')
plt.title('Customer Service Interactions vs. Account Closure')
plt.xlabel('Customer Service Interactions')
plt.ylabel('Account Closure')
plt.grid(True)






plt.show()





import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests, calendar

print(calendar.month(2023,10))



CCCCCCCCCCCCCCCCCCCC*963



# Set a title for your dashboard
st.title("Streamlit Dashboard with Weather and Air Quality Gadgets")

# Generate some random data
data = pd.DataFrame({
    'Date': pd.date_range(start='2023-01-01', periods=100, freq='D'),
    'Value': np.random.randn(100).cumsum(),
    'Category': np.random.choice(['A', 'B', 'C'], 100)
})

# Create a sidebar widget to customize data
st.sidebar.header("Data Options")

# Allow the user to choose the number of data points to display
num_points = st.sidebar.slider("Number of Data Points", 10, 100, 50)

 




# Create additional widgets
st.sidebar.header("Additional Widgets")

# Checkbox to show/hide the scatter plot
show_scatter_plot = st.sidebar.checkbox("Show Scatter Plot")
if show_scatter_plot:
    st.write("### Scatter Plot")
    st.markdown("Description of the scatter plot goes here...")

# Weather gadget (generated data)
st.sidebar.header("Weather Gadget (Generated Data)")

# Simulate weather data
temperature = np.random.randint(15, 30)  # Simulated temperature in Celsius
humidity = np.random.randint(30, 70)  # Simulated humidity in percentage
pressure = np.random.randint(980, 1030)  # Simulated atmospheric pressure in hPa
wind_speed = np.random.uniform(0, 10)  # Simulated wind speed in m/s
wind_direction = np.random.randint(0, 360)  # Simulated wind direction in degrees

st.sidebar.write(f"Temperature: {temperature}°C")
st.sidebar.write(f"Humidity: {humidity}%")
st.sidebar.write(f"Pressure: {pressure} hPa")
st.sidebar.write(f"Wind Speed: {wind_speed} m/s")
st.sidebar.write(f"Wind Direction: {wind_direction}°")

# Air quality gadget (generated data)
st.sidebar.header("Air Quality Gadget (Generated Data)")

# Simulate CO2 data
co2_data = np.random.randint(300, 1000)  # Simulated CO2 levels in ppm

st.sidebar.write(f"CO2 Level: {co2_data} ppm")

# You can add more widgets and visualizations as needed














# Create custom subplots
st.write("### Custom Subplots:")
fig, axes = plt.subplots(1, 2, figsize=(12, 4))

# Subplot 1: Pie Chart
sizes = [30, 45, 25]
labels = ['Category A', 'Category B', 'Category C']
explode = (0.1, 0, 0)
axes[0].pie(sizes, labels=labels, explode=explode, autopct='%1.1f%%', shadow=True, startangle=90)
axes[0].set_title('Pie Chart')

# Subplot 2: Box Plot
axes[1].boxplot(data['Value'].head(num_points), vert=False)
axes[1].set_title('Box Plot')



# How to hide or modify "Made with Streamlit" at bottom page
# Credit : https://github.com/streamlit/streamlit/issues/892
hide_streamlit_style = """
            <style>
            #MainMenu {visibility: hidden;}
            footer {visibility: hidden;}
            </style>
            """
st.markdown(hide_streamlit_style, unsafe_allow_html=True) 


# Adjust spacing between subplots
plt.tight_layout()

# Display the custom subplots
st.pyplot(fig)

# You can add more widgets and visualizations as needed




import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Set a title for your dashboard
st.title("Streamlit Dashboard with Custom Subplots")

# Generate some random data
data = pd.DataFrame({
    'Date': pd.date_range(start='2023-01-01', periods=100, freq='D'),
    'Value': np.random.randn(100).cumsum()
})

# Create a sidebar widget to customize data
st.sidebar.header("Data Options")

# Allow the user to choose the number of data points to display
num_points = st.sidebar.slider("Number of Data Points", 10, 100, 50)

 ## Display the selected data in a table
#st.write("### Displaying Random Data:")
#st.dataframe(data.head(num_points))


# Create custom subplots
st.write("### Custom Subplots:")
fig = plt.figure( figsize=(12, 4))
# Subplot 1: Pie Chart
sizes = [30, 45, 25]
labels = ['Category A', 'Category B', 'Category C']
explode = (0.1, 0, 0)
ax1 = fig.add_subplot(221)
ax1.pie(sizes, labels=labels, explode=explode, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.set_title('Pie Chart')

# Subplot 2: Box Plot
ax2 = fig.add_subplot(222)
ax2.boxplot(data['Value'].head(num_points), vert=False)
ax2.set_title('Box Plot')


# Subplot 3: # Create a line chart of the generated data
ax3 = fig.add_subplot(223)
ax3.set_title("### Line Chart:")

ax3.plot(data['Value'].head(num_points))




# Adjust spacing between subplots
#plt.tight_layout()

# Display the custom subplots
st.pyplot(fig)

# You can add more widgets and visualizations as needed













import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests

# Set a title for your dashboard
st.title("Streamlit Dashboard with Panels, Subplots, and Weather Gadget")

# Generate some random data
data = pd.DataFrame({
    'Date': pd.date_range(start='2023-01-01', periods=100, freq='D'),
    'Value': np.random.randn(100).cumsum(),
    'Category': np.random.choice(['A', 'B', 'C'], 100)
})

# Create a sidebar widget to customize data
st.sidebar.header("Data Options")

# Allow the user to choose the number of data points to display
num_points = st.sidebar.slider("Number of Data Points", 10, 100, 50)

 
st.sidebar.header("Weather Gadget")
# Placeholder weather data (replace with actual weather API data)
weather_data = {
    'City': 'New York',
    'Temperature': '22°C',
    'Weather': 'Sunny',
}
st.sidebar.subheader(weather_data['City'])
st.sidebar.write(f"Temperature: {weather_data['Temperature']}")
st.sidebar.write(f"Weather: {weather_data['Weather']}")












# Display the selected data in a table
st.write("### Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data Displaying Random Data:")
st.dataframe(data.head(num_points))











import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests

# Set a title for your dashboard
st.title("Streamlit Dashboard with Weather and Air Quality Gadgets")

# Generate some random data
data = pd.DataFrame({
    'Date': pd.date_range(start='2023-01-01', periods=100, freq='D'),
    'Value': np.random.randn(100).cumsum(),
    'Category': np.random.choice(['A', 'B', 'C'], 100)
})

# Create a sidebar widget to customize data
st.sidebar.header("Data Options")

# Allow the user to choose the number of data points to display
num_points = st.sidebar.slider("Number of Data Points", 10, 100, 50)

 




# Create additional widgets
st.sidebar.header("Additional Widgets")

# Checkbox to show/hide the scatter plot
show_scatter_plot = st.sidebar.checkbox("Show Scatter Plot")
if show_scatter_plot:
    st.write("### Scatter Plot")
    st.markdown("Description of the scatter plot goes here...")

# Weather gadget (generated data)
st.sidebar.header("Weather Gadget (Generated Data)")

# Simulate weather data
temperature = np.random.randint(15, 30)  # Simulated temperature in Celsius
humidity = np.random.randint(30, 70)  # Simulated humidity in percentage
pressure = np.random.randint(980, 1030)  # Simulated atmospheric pressure in hPa
wind_speed = np.random.uniform(0, 10)  # Simulated wind speed in m/s
wind_direction = np.random.randint(0, 360)  # Simulated wind direction in degrees

st.sidebar.write(f"Temperature: {temperature}°C")
st.sidebar.write(f"Humidity: {humidity}%")
st.sidebar.write(f"Pressure: {pressure} hPa")
st.sidebar.write(f"Wind Speed: {wind_speed} m/s")
st.sidebar.write(f"Wind Direction: {wind_direction}°")

# Air quality gadget (generated data)
st.sidebar.header("Air Quality Gadget (Generated Data)")

# Simulate CO2 data
co2_data = np.random.randint(300, 1000)  # Simulated CO2 levels in ppm

st.sidebar.write(f"CO2 Level: {co2_data} ppm")

# You can add more widgets and visualizations as needed














# Create custom subplots
st.write("### Custom Subplots:")
fig, axes = plt.subplots(1, 2, figsize=(12, 4))

# Subplot 1: Pie Chart
sizes = [30, 45, 25]
labels = ['Category A', 'Category B', 'Category C']
explode = (0.1, 0, 0)
axes[0].pie(sizes, labels=labels, explode=explode, autopct='%1.1f%%', shadow=True, startangle=90)
axes[0].set_title('Pie Chart')

# Subplot 2: Box Plot
axes[1].boxplot(data['Value'].head(num_points), vert=False)
axes[1].set_title('Box Plot')



# How to hide or modify "Made with Streamlit" at bottom page
# Credit : https://github.com/streamlit/streamlit/issues/892
hide_streamlit_style = """
            <style>
            #MainMenu {visibility: hidden;}
            footer {visibility: hidden;}
            </style>
            """
st.markdown(hide_streamlit_style, unsafe_allow_html=True) 


# Adjust spacing between subplots
plt.tight_layout()

# Display the custom subplots
st.pyplot(fig)

# You can add more widgets and visualizations as needed



















